/**
 * Commit operations with coauthor support
 */

import type { CommitInfo, AppConfig } from '../types/index.js';
import { getGitHubClient } from './client.js';
import { getCoauthorTrailer } from '../utils/config.js';
import logger from '../utils/logger.js';

/**
 * Create a file with content and commit it
 */
export async function createFileCommit(
  owner: string,
  repo: string,
  options: {
    path: string;
    content: string;
    message: string;
    branch: string;
    coauthor?: { name: string; email: string };
  }
): Promise<CommitInfo> {
  const client = getGitHubClient();

  // Build commit message with optional coauthor
  let commitMessage = options.message;
  if (options.coauthor) {
    commitMessage += `\n\nCo-authored-by: ${options.coauthor.name} <${options.coauthor.email}>`;
  }

  logger.debug(`Creating commit on ${options.branch}: ${options.message}`);

  // Check if file exists to get its SHA
  let existingSha: string | undefined;
  try {
    const existing = await client.api.repos.getContent({
      owner,
      repo,
      path: options.path,
      ref: options.branch,
    });

    if (!Array.isArray(existing.data) && 'sha' in existing.data) {
      existingSha = existing.data.sha;
    }
  } catch (error) {
    // File doesn't exist, that's fine
    const anyError = error as { status?: number };
    if (anyError.status !== 404) {
      throw error;
    }
  }

  // Create or update the file
  const response = await client.api.repos.createOrUpdateFileContents({
    owner,
    repo,
    path: options.path,
    message: commitMessage,
    content: Buffer.from(options.content).toString('base64'),
    branch: options.branch,
    sha: existingSha,
  });

  const commitSha = response.data.commit.sha || '';

  logger.verbose(`Created commit ${commitSha.substring(0, 7)}`);

  return {
    sha: commitSha,
    message: options.message,
    url: response.data.commit.html_url ?? '',
  };
}

/**
 * Get file content from a branch
 */
export async function getFileContent(
  owner: string,
  repo: string,
  path: string,
  branch?: string
): Promise<{ content: string; sha: string } | null> {
  const client = getGitHubClient();

  try {
    const response = await client.api.repos.getContent({
      owner,
      repo,
      path,
      ref: branch,
    });

    if (!Array.isArray(response.data) && 'content' in response.data) {
      return {
        content: Buffer.from(response.data.content, 'base64').toString('utf-8'),
        sha: response.data.sha,
      };
    }

    return null;
  } catch (error) {
    const anyError = error as { status?: number };
    if (anyError.status === 404) {
      return null;
    }
    throw error;
  }
}

/**
 * Append content to an existing file or create it
 */
export async function appendToFile(
  owner: string,
  repo: string,
  options: {
    path: string;
    contentToAppend: string;
    message: string;
    branch: string;
    coauthor?: { name: string; email: string };
  }
): Promise<CommitInfo> {
  // Get existing content
  const existing = await getFileContent(owner, repo, options.path, options.branch);

  let newContent: string;
  if (existing) {
    newContent = existing.content + '\n' + options.contentToAppend;
  } else {
    newContent = options.contentToAppend;
  }

  return createFileCommit(owner, repo, {
    path: options.path,
    content: newContent,
    message: options.message,
    branch: options.branch,
    coauthor: options.coauthor,
  });
}

/**
 * Create a commit for an achievement entry
 * Uses unique files per operation to prevent merge conflicts
 */
export async function createAchievementCommit(
  owner: string,
  repo: string,
  options: {
    branch: string;
    achievementName: string;
    number: number;
    tier: string;
    coauthor?: { name: string; email: string };
  }
): Promise<CommitInfo> {
  const timestamp = new Date().toISOString();
  const uniqueId = `${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;

  // Use unique file path to prevent merge conflicts
  const filePath = `.achievements/${options.achievementName.toLowerCase().replace(/\s+/g, '-')}/${options.number}-${uniqueId}.md`;

  const content = `# ${options.achievementName} - Operation #${options.number}

**Tier:** ${options.tier}
**Timestamp:** ${timestamp}
**Operation:** ${options.number}

---
*Generated by GitHub Achievements Manager*
`;

  const commitMessage = `Achievement: ${options.achievementName} #${options.number}`;

  return createFileCommit(owner, repo, {
    path: filePath,
    content,
    message: commitMessage,
    branch: options.branch,
    coauthor: options.coauthor,
  });
}

/**
 * Initialize the achievements directory (optional - creates README)
 * No longer required since each operation creates unique files
 */
export async function initAchievementsFile(
  owner: string,
  repo: string,
  defaultBranch: string
): Promise<void> {
  // Check if .achievements/README.md exists
  const existing = await getFileContent(owner, repo, '.achievements/README.md', defaultBranch);

  if (!existing) {
    const initialContent = `# GitHub Achievements

This directory contains achievement operation records created by the GitHub Achievements Manager.

Each subdirectory corresponds to an achievement type, and each file represents a completed operation.

**Note:** These files are auto-generated and can be safely deleted after achievements are unlocked.

---
*Generated by [GitHub Achievements Manager](https://github.com/your-repo)*
`;

    try {
      await createFileCommit(owner, repo, {
        path: '.achievements/README.md',
        content: initialContent,
        message: 'Initialize achievements tracking directory',
        branch: defaultBranch,
      });
      logger.info('Created .achievements/README.md file');
    } catch (error) {
      // Not critical if this fails - operations will still create their own files
      logger.debug('Could not create README.md, continuing anyway');
    }
  }
}

/**
 * Create a commit with just a message (for testing)
 */
export async function createEmptyCommit(
  owner: string,
  repo: string,
  options: {
    message: string;
    branch: string;
    coauthor?: { name: string; email: string };
  }
): Promise<CommitInfo> {
  // Create a unique file for each commit to ensure changes
  const uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
  const content = `Commit: ${uniqueId}\nTimestamp: ${new Date().toISOString()}`;

  return createFileCommit(owner, repo, {
    path: `.achievements/${uniqueId}.txt`,
    content,
    message: options.message,
    branch: options.branch,
    coauthor: options.coauthor,
  });
}

export default {
  createFileCommit,
  getFileContent,
  appendToFile,
  createAchievementCommit,
  initAchievementsFile,
  createEmptyCommit,
};
